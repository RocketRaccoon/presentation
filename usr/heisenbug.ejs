<div class="slides">


    <section class="stack">
        <section>
            <h3>
                <div>Полный цикл тестирования микросервисов</div>
                <div> в Docker контейнерах</div>
            </h3>
        </section>
    </section>

    <!--
    ## 1 - Монолит, Релизный цикл, Большая Регрессия, Сложное Окружение
    ## Андрей
    ## Проблема: команда работает с одним большим сервисом. Общая кодовая база и длинный релизный цикл, сложное окружение (трудно изолировать сервис для тестирования), много интеграционных тестов, регрессия выполняется долго;
    ## Решение: разбиваем сервис на микросервисы;
    ## Решение: пирамида тестирования - больше модульных и компонентных тестов;
    ## Решение: на каждый коммит прогоняем тесты (юнит, компонентные, интеграционные)
    ## Описание (Разбиваем на микросервисы -> рассказываем о плюшках для тестирования)
    -->
    <section class="stack">
        <section data-transition="slide-in fade-out">
            <h2>
                <div class="fragment">Монолиты</div>
                <div class="fragment">Релизы</div>
                <div class="fragment">Регрессии</div>
                <div class="fragment">Окружения</div>
            </h2>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Монолитный сервис</h2>
            <ul>
                <li class="fragment">Предоставляет API для облачной телефонии</li>
                <li class="fragment">Часть большой инфраструктуры</li>
                <li class="fragment">В процессе декомпозиции на микросервисы</li>
                <li class="fragment">Размер проекта - 466,000 SLOC</li>
                <li class="fragment">Интеграционных тестов - 229,000 SLOC</li>
                <li class="fragment">Описание тестов - 200,000 LOC</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Релизный цикл</h2>
            <ul>
                <li class="fragment">Релиз каждые 3 месяца</li>
                <li class="fragment">В проекте 7 команд</li>
                <li class="fragment">Функционал разрабатывается в отдельных ветках</li>
                <li class="fragment">В общую ветку код сливается после прохождения регрессии на эталонном окружении</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Регрессионное тестирование</h2>
            <ul>
                <li class="fragment">15,000 тестов за 75 минут</li>
                <li class="fragment">Подготовка тестовых данных занимает 4 часа</li>
                <li class="fragment">Даже для одной задачи требуется полный прогон</li>
                <li class="fragment">Один день - одна команда</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Окружения</h2>
            <ul>
                <li class="fragment">Стандартное окружение - 70 VM, 120 vCPU, 160GB RAM</li>
                <li class="fragment">Окружение для каждой команды</li>
                <li class="fragment">4 общих окружения для проекта</li>
                <li class="fragment">Выделенная команда для поддержки окружений</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Как микросервисы меняют тестирование?</h2>
            <ul>
                <li class="fragment">Каждый сервис имеет отдельный релизный цикл</li>
                <li class="fragment">Выпускаем меньше изменений за один раз</li>
                <li class="fragment">Интеграционных тестов меньше (интеграции?)</li>
                <li class="fragment">Компонентных тестов больше</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Как микросервисы меняют тестирование?</h2>
            <ul>
                <li class="fragment">На каждый коммит запускаются все виды тестов</li>
                <li class="fragment">Тестовых заглушек меньше и они проще (интеграции?)</li>
                <li class="fragment">В микросервисе проще (факты?) внедрять новые подходы к тестированию</li>
                <li class="fragment">Требуется меньше ресурсов CI сервера</li>
            </ul>
        </section>
    </section>

    <!--
    ## 2 - Больше фич в один момент времени -> нужно больше окружений
    ## Андрей
    ## Дмитрий
    ## Проблема: каждой команде необходимо свое окружение, а также общие окружения для интеграции. При этом окружения должны быть похожи на продакшн. Одновременная разработка нескольких версий сервиса.
    ## Решение: система управления окружениями
    -->
    <section class="stack">
        <section data-transition="slide-in fade-out">
            <h2>Окружение разработки и тестирования</h2>
            <ul>
                <li class="fragment">Больше фич и команд - больше окружений необходимо</li>
                <li class="fragment">Необходим котроль за состоянием окружений</li>
                <li class="fragment">Единый механизм установки сервисов в DEV и PROD</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>
                <div>Система управления окружениями</div>
                <div class="fragment">и конфигурациями</div>
            </h2>
            <ul>
                <li class="fragment">Хранит артефакты для установки</li>
                <li class="fragment">Хранит конфигурации окружений и управляет ими</li>
                <li class="fragment">Развертывает окружения</li>
                <li class="fragment">Используется абсолютно для всех окружений</li>
                <li class="fragment">Способна эффективно управлять сотнями окружений</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>
                <div>Система управления окружениями</div>
                <div>и конфигурациями</div>
            </h2>
            <ul>
                <li class="fragment">Можно сделать из подручных средств и палок</li>
                <li class="fragment">Артефакты для установки - Nexus, Docker Registry, FTP</li>
                <li class="fragment">Хранилище конфигураций и деплоймент - Puppet, Chief, Ansible</li>
                <li class="fragment">Управление ресурсами - VMware, Mesosphere</li>
            </ul>
        </section>
    </section>

    <!--
    ## 3 - Много окружений -> один способ доставки
    ## Дмитрий
    ## Проблема: у разных сервисов разные требования к софту и способы установки;
    ## Решение: используем Docker контейнеры;
    ## Описание
    Необходим единный способ развертывания сервисов во всех средах.
    Плюс уменьшение парка SWE/HWE. Уменьшить нагрузку на devops. Иметь возможность быстро менять системные требования к софту.
    -->
    <section class="stack">

        <section data-transition="slide-in fade-out">
            <h2>Возможные способы дистрибуции сервисов</h2>
            <ul style="text-align: left;">
                <li class="fragment" data-fragment-index="1">VM + Package Manager</li>
                <li class="fragment" data-fragment-index="2">Docker</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>VM + Package Manager</h2>
            <ul style="text-align: left;">
                <li class="fragment" data-fragment-index="1">Брольшой размер виртуальной машины</li>
                <li class="fragment" data-fragment-index="2">Машина "долго" стартует</li>
                <li class="fragment" data-fragment-index="3">Сложный процесс разработки SWE/HWE и деплоя приложения (заменить!)</li>
                <li class="fragment" data-fragment-index="4">Сложно локально протестировать новую версию виртуальной машины</li>
                <li class="fragment" data-fragment-index="5">Нет четкой связи между версией виртуальной машины и версией приложения</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Docker</h2>
            <h3 class="fragment" data-fragment-index="0" >Build once, Run anywhere</h3>
            <ul style="text-align: left;">
                <li class="fragment" data-fragment-index="1">Меньший размер image'a (Microcontainers)</li>
                <li class="fragment" data-fragment-index="2">Быстрый старт</li>
                <li class="fragment" data-fragment-index="3">Окружение сервиса конфигурируется разработчиком</li>
                <li class="fragment" data-fragment-index="4">Один и тот же контейнер на всех окружениях</li>
            </ul>
        </section>

    </section>

    <!--
    ## 4 - Фрэймворк для момнолита плохо работает с микросервисами
    ## Андрей
    ## Проблема: любой монолитный тестовый фреймворк со временем превращается в кракена. Его становится тяжело обновлять, расширять и использовать в других проектах;
    ## Решение: декомпозиция фреймворка на модули, принцип единой ответственности;
    ## Описание
    -->
    <section class="stack">
        <section data-transition="slide-in fade-out">
            <h2>Фрэймворки и Кракены</h2>
            <ul style="text-align: left;">
                <li class="fragment">Монолитному сервису - монолитный фрэимворк</li>
                <li class="fragment">Базовый функционал для тестов (?)</li>
                <li class="fragment">Интеграция с внутренними системами</li>
                <li class="fragment">Функционал предоставляется через наследование базового класса</li>
                <li class="fragment">Разные модули жестко связаны между собой</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Фрэймворки и Кракены</h2>
            <ul style="text-align: left;">
                <li class="fragment">Лишние зависимости съедают ресурсы CI сервера</li>
                <li class="fragment">Изменение во фрэймворке влияет на всю компанию (кол-во команд или людей!)</li>
                <li class="fragment">В каждом проекте оброс отдельными доработками</li>
                <li class="fragment">Сложно обновлять версии ключевых библиотек</li>
                <li class="fragment">Увеличенный порог вхождения</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Картинка с абстрактным кракеном</h2>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>
                <div>Что делать?</div>
            </h2>
            <div class="fragment">когда текущий тестовый фрэймворк <em>уже</em> не получился,</div>
            <div class="fragment">а новый <em>ещё</em> не получился</div>
            <ul style="text-align: left;">
                <li class="fragment">Разделить на независимые модули</li>
                <li class="fragment">Сделать взаимодействие через API</li>
                <li class="fragment">Вместо костылей - вносить вклад в используемые проекты</li>
                <li class="fragment">При тестировании сервиса подключать только то, что нужно</li>
                <li class="fragment">Тестировать</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Картинка с Wonderful Testing Framework</h2>
        </section>
    </section>

    <!--
    ## 5
    ## Андрей
    ## Проблема: тесты запускаются параллельно на нескольких машинах, необходимо объединять все отчёты;
    ## Решение: использование Allure Reports, Report Portal(?);
    ## Описание
    -->
    <section class="stack">
        <section data-transition="slide-in fade-out">
            <h2>Отчеты по тестированию</h2>
            <ul style="text-align: left;">
                <li class="fragment">При тестировании множества сервисов необходимо объединять разные отчеты в один</li>
                <li class="fragment">Стандартные отчеты плохо (как именно?) справляются с этой задачей</li>
                <li class="fragment">При большом количестве данных производительность отчета становится проблемой</li>
                <li class="fragment">Приходится дорабатывать либо делать свое решение с нуля</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Что надо?</h2>
            <ul style="text-align: left;">
                <li class="fragment">Собирать много отчетов в один (объеденить с 3!)</li>
                <li class="fragment">Разные уровни детализации (какие?)</li>
                <li class="fragment">Показывать информацию из множества источников (каких?)</li>
                <li class="fragment">API для интеграции</li>
                <li class="fragment">Результаты в реальном времени</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <p>(расскажем об опыте использование, какие рекомендации для себя вынесли)</p>
            <h3 class="fragment">Yandex Allure Report</h3>
            <ul style="text-align: left;">
                <li class="fragment">Супер Фича</li>
                <li class="fragment">Супер Фича</li>
                <li class="fragment">Проблема</li>
            </ul>
            <h2 class="fragment">Epam Report Portal</h2>
            <ul style="text-align: left;">
                <li class="fragment">Супер Фича</li>
                <li class="fragment">Супер Фича</li>
                <li class="fragment">Проблема</li>
            </ul>
        </section>
    </section>


    <!--
        ## 6
        ## Дмитрий
        ## Проблема: одна команда сделала изменение, которое должно попасть ко всем. После этого необходимо изменить xml шаблон,
        ## а остальные должны самостоятельно из него обновиться.
        ## Решение: Jenkins Pipeline, использование Job DSL, хранение конфигурации в репозитории проекта;
        ## Описание
        Как лучше организовать сборку?
        Есть много билдеров, есть тест экзекуторы, много проектов и видов тестов, определенный набор ПО для слэйвов.
        Приходится делать очень много слэйвов с разными конфигурациями
        (когда это обслуживается отдельным отделом добавляются бюрократические сложности и тратится время на ожидание),
        но все равно в определенный момент (перед релизом) появляется очередь на прогон тестов, сборок и т.п. (все подходящие слэйвы заняты).
        При это много свободных, которые не подходят. Есть проблема как обновлять конфигурацию на слэйвах, так как это может сломать другие сборки.
        Команда сама создает слэйв в контейнере с нужным конфигом под необходимое окружение.
        Слэйвы в нужном количестве создаются на момент сборки, а потом удаляются при необходимости.
        Конфигурация джобы хранится в проетке и версионируется. По запросу мы получаем доступ к необходимому количеству ресурсов.
        Пайплайн позволяет это все интегрировать в единый цикл тестирования.
     -->
    <section class="stack">

        <section data-transition="slide-in fade-out">
            <h2>Delivery Pipeline as Code</h2>
            <p>Поменять местами с репортингом</p>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Как мы работаем с Jenkins</h2>
            <ul style="text-align: left;">
                <li class="fragment" data-fragment-index="1">Для каждой команды отдельное окружение</li>
                <li class="fragment" data-fragment-index="2">Для каждого окружения свой набор Job</li>
                <li class="fragment" data-fragment-index="3">Job'ы создаются из темплейтов</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Platform - The Numbers</h2>
            <ul style="text-align: left;">
                <li class="fragment" data-fragment-index="1">Slaves?</li>
                <li class="fragment" data-fragment-index="1">Jobs?</li>
                <li class="fragment" data-fragment-index="1">Environments?</li>
                <li class="fragment" data-fragment-index="1">Executions?</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Как этот подход работает с микросервисами?</h2>
            <ul style="text-align: left;">
                <li class="fragment" data-fragment-index="1">Для каждой команды отдельное окружение</li>
                <li class="fragment" data-fragment-index="2">Для каждого сервиса свой набор Job</li>
                <li class="fragment" data-fragment-index="3">Job'ы для каждого сервиса создаются из темплейтов</li>
                <li class="fragment" data-fragment-index="4">Job'ы для каждого окружения создаются из темплейтов</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Какие проблемы у этого подхода?</h2>
            <ul style="text-align: left;">
                <li class="fragment" data-fragment-index="1">Отсутствие версионирования</li>
                <li class="fragment" data-fragment-index="2">Дублирование логики в job'ах</li>
                <li class="fragment" data-fragment-index="3">Сложно вносить изменения</li>
                <li class="fragment" data-fragment-index="4">Необходимо пересоздавать job'ы после изменения темплейтов</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Pipeline as Code</h2>
            <ol style="text-align: left;">
                <li class="fragment" data-fragment-index="1">Job'ы создаются с помощью Groovy script</li>
                <li class="fragment" data-fragment-index="2">Pipeline объявляется в Jenkinsfile и хранятся вместе с кодом</li>
            </ol>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Manual steps in Pipeline</h2>
            <ol style="text-align: left;">
            </ol>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Stage View</h2>
            <ul style="text-align: left;">
                <li class="fragment" data-fragment-index="1">Каждый pipeline состоит из stage</li>
                <li class="fragment" data-fragment-index="2">Каждый stage содержит 1 или более шагов (steps)</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Docker Support</h2>
            <!--
            https://www.cloudbees.com/blog/orchestrating-workflows-jenkins-and-docker
            http://www.slideshare.net/cloudbees/juc-europe-2015-from-virtual-machines-to-containers-achieving-continuous-integration-build-reproducibility-isolation-and-scalability?qid=da43606e-9da7-4d87-ba1e-64da35c76d8f&v=&b=&from_search=4
            https://github.com/maxfields2000/dockerjenkins_tutorial/tree/master/tutorial_07
            http://www.slideshare.net/SlawaGiterman/delivery-pipeline-as-code-using-jenkins-20-pipeline
            -->
            <ul style="text-align: left;">
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Infrastructure as Code</h2>
            <ul style="text-align: left;">
                <li class="fragment">Пример кода?</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Reuse Pipeline modules</h2>
            <ul style="text-align: left;">
                <li class="fragment">Пример кода?</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Use Scripts in other languages</h2>
            <ul style="text-align: left;">
                <li class="fragment">Пример кода?</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Example</h2>
            <ul style="text-align: left;">
                <li class="fragment">Пример полного пайплайна</li>
            </ul>
        </section>

        <section data-transition="slide-in fade-out">
            <h2>Blue Ocean UI???</h2>
            <ul style="text-align: left;">
                <li class="fragment">Ближайшее будущее, переосмысление UI</li>
            </ul>
        </section>



    </section>

    <section class="stack">

        <section data-transition="slide-in fade-out">
            <h2>Чем закончить?</h2>
        </section>
    </section>

</div>
